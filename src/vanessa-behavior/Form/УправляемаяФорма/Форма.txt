&НаКлиенте
Перем WinSocket,СтримAdobe,МассивДляСозданияEpf,МассивНайденыхФич,ШагСтрокДляМодуля;
&НаКлиенте
Перем ОшибкаВнутриОбработкиВызоваBDD,АргументыКоманднойСтроки,БылиОшибкиЗапускаКукумбера;

&НаКлиенте
Перем КолСекундПростоя,МассивФайловФичДляГенерации,ТекущаяПозицияМассивФайловФичДляГенерации,СостояниеИдетГенерация,СостояниеИдетInvoke,ИмяТекущейФичи,RegExp,ЭтоУФ,ОбъектКонтекст;
&НаКлиенте
Перем МассивКонтекстовОбработок,МассивИменФайлов;





&НаКлиенте
Процедура СделатьСообщение(Знач Сообщение) Экспорт
	Сообщить(Строка(ТекущаяДата()) + " " + Сообщение);
КонецПроцедуры

&НаСервере
Процедура СделатьСообщениеСервер(Знач Сообщение) Экспорт
	Сообщить(Строка(ТекущаяДата()) + " " + Сообщение);
КонецПроцедуры


&НаКлиенте
Процедура Отладка(Знач Сообщение) Экспорт
	Если Объект.DebugLog Тогда
		СделатьСообщение(Сообщение);
	КонецЕсли; 
КонецПроцедуры


&НаКлиенте
Процедура ЗаписатьВЖурнал(ТипСобытия, ТекстСобытия)
	Сообщить("" + ТекущаяДата() + " " + ТипСобытия +": " + ТекстСобытия);
КонецПроцедуры

&НаКлиенте
Процедура ПрерватьВыполнениеСкрипта(ТекстИсключения) Экспорт
	ВызватьИсключение(ТекстИсключения);
КонецПроцедуры


&НаКлиенте
Процедура Приостановить(Интервал)
	//Сообщить("Начало sleep...");
	НовЗнач = ТекущаяУниверсальнаяДатаВМиллисекундах() + Интервал;
	Пока ТекущаяУниверсальнаяДатаВМиллисекундах() < НовЗнач Цикл
		Продолжить;
	КонецЦикла; 
	//Сообщить("Окончание sleep...");
КонецПроцедуры


&НаКлиенте
Функция ПерекодировкаДляОтправкиОшибки(Стр="",Кодировка="windows-1251") 
    СтримAdobe.Type = 2;
	СтримAdobe.Mode= 3;
	СтримAdobe.charset="utf-8";
	СтримAdobe.Open();
	СтримAdobe.WriteText(Стр);
	СтримAdobe.Position=0;
	СтримAdobe.charset=Кодировка;
	Рез=СтримAdobe.ReadText(-1);
    СтримAdobe.Close();
    Возврат    Рез;
КонецФункции


&НаКлиенте
Функция Перекодировка(Стр="",Кодировка="utf-8") 
    СтримAdobe.Type = 2;
	СтримAdobe.Mode= 3;
	СтримAdobe.charset="windows-1251";
	СтримAdobe.Open();
	Попытка
		СтримAdobe.WriteText(Стр);
		СтримAdobe.Position=0;
		СтримAdobe.charset=Кодировка;
		Рез=СтримAdobe.ReadText(-1);
	Исключение
		//перекодировка падает на invoke, видимо из-за разной кодировки строк
		Рез = Стр;
	КонецПопытки;
    СтримAdobe.Close();
    Возврат    Рез;
КонецФункции


&НаСервере
Процедура ВосстановитьНастройки()
	Настройки = ХранилищеОбщихНастроек.Загрузить("VanessaBehavior");
	Если ТипЗнч(Настройки) = Тип("Структура") Тогда
		
		Настройки.Свойство("DebugLog", Объект.DebugLog);
		//Настройки.Свойство("GenerateEpf", Объект.GenerateEpf);
		//Настройки.Свойство("TestRun", Объект.TestRun);
		Настройки.Свойство("ГенерироватьУФ", Объект.ГенерироватьУФ);
		Настройки.Свойство("КаталогИнструментов", Объект.КаталогИнструментов);
		Настройки.Свойство("КаталогФич", Объект.КаталогФич);
	КонецЕсли;
	
	//Элементы.DebugLog.Пометка = Объект.DebugLog;
	//Элементы.GenerateEpf.Пометка = Объект.GenerateEpf;
	//Элементы.TestRun.Пометка = Объект.TestRun;
КонецПроцедуры

&НаСервере
Процедура СохранитьНастройки()
	Настройки = Новый Структура;
	Настройки.Вставить("DebugLog", Объект.DebugLog);
	//Настройки.Вставить("GenerateEpf", Объект.GenerateEpf);
	//Настройки.Вставить("TestRun", Объект.TestRun);
	Настройки.Вставить("ГенерироватьУФ", Объект.ГенерироватьУФ);
	Настройки.Вставить("КаталогИнструментов", Объект.КаталогИнструментов);
	Настройки.Вставить("КаталогФич", Объект.КаталогФич);
	ХранилищеОбщихНастроек.Сохранить("VanessaBehavior",, Настройки);
КонецПроцедуры

&НаКлиенте
Процедура ПриЗакрытии()
	Если Не ЭтоЗапускИзКоманднойСтроки Тогда
		СохранитьНастройки();
	КонецЕсли;
	WinSocket = Неопределено;
КонецПроцедуры


//часть WinSocket - начало

&НаКлиенте
Процедура WinSocketError(Number, Description, Scode, Source, HelpFile, HelpContext, CancelDisplay)
	Отладка(Description);
КонецПроцедуры

&НаСервере
Функция Это_step_matches_name_to_match(ПромСтр,ПолезноеЗначение)
	Объект1 = РеквизитФормыВЗначение("Объект");
	Возврат Объект1.Это_step_matches_name_to_match(ПромСтр,ПолезноеЗначение);
КонецФункции


&НаКлиенте
Процедура УбратьЗапрещенныеСимволыИзStepDefinition(StepDefinition)
	StepDefinition = СтрЗаменить(StepDefinition,".","");
	StepDefinition = СтрЗаменить(StepDefinition,",","");
	StepDefinition = СтрЗаменить(StepDefinition,":","");
	StepDefinition = СтрЗаменить(StepDefinition,";","");
	StepDefinition = СтрЗаменить(StepDefinition,"-","_");
	StepDefinition = СтрЗаменить(StepDefinition,"+","");
КонецПроцедуры


&НаСервереБезКонтекста
Функция РазложитьСтрокуВМассивПодстрок(Знач Строка, Знач Разделитель = ",", Знач ПропускатьПустыеСтроки = Неопределено) Экспорт
	
	Результат = Новый Массив;
	
	// для обеспечения обратной совместимости
	Если ПропускатьПустыеСтроки = Неопределено Тогда
		ПропускатьПустыеСтроки = ?(Разделитель = " ", Истина, Ложь);
		Если ПустаяСтрока(Строка) Тогда 
			Если Разделитель = " " Тогда
				Результат.Добавить("");
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	//
	
	Позиция = Найти(Строка, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Строка, Позиция - 1);
		Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Подстрока) Тогда
			Результат.Добавить(Подстрока);
		КонецЕсли;
		Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
		Позиция = Найти(Строка, Разделитель);
	КонецЦикла;
	
	Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Строка) Тогда
		Результат.Добавить(Строка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции 


&НаКлиенте
Функция ДобавитьПараметрStepDefinition(Знач Стр,КолПараметров) Экспорт
	КолПараметровСтр = СокрЛП(КолПараметров);
	Если СтрДлина(КолПараметровСтр) = 1 Тогда
		КолПараметровСтр = "0" + КолПараметровСтр;
	КонецЕсли;
	
	Стр = СтрЗаменить(Стр,"<Параметр","<Парам" + КолПараметровСтр) + ",";
	Стр = СтрЗаменить(Стр,"<","");
	Стр = СтрЗаменить(Стр,">","");
	
	Возврат Стр;
КонецФункции


&НаКлиенте
Функция СделатьПервуюБуквуЗаглавной(Стр) Экспорт
	Если СтрДлина(Стр) = 0 Тогда
		Возврат Стр;
	КонецЕсли;
	
	ПерваяБуква = ВРег(Лев(Стр,1));
	
	Возврат ПерваяБуква + Сред(Стр,2);
КонецФункции


&НаКлиенте
Функция ПолучитьStepDefinition(Знач Стр,args) 
	
	Стр = СтрЗаменить(Стр,"\""","'");//чтобы \" заменить на апостроф
	
	StepDefinition = "";
	args = "";
	ПараметрыЧисла  = Новый Массив;
	ПараметрыСтроки = Новый Массив;
	ПараметрыДаты   = Новый Массив;
	
	//найдём параметры строки
	RegExp.Pattern = "\'[^\']+\'"; 
	ПараметрыRegExp=RegExp.Execute(стр); 
	Для i=0 По ПараметрыRegExp.Count-1 Цикл
		Item = ПараметрыRegExp.Item(i);
		ПромСтр = Item.Value;
		Если Лев(ПромСтр,1) = "'" Тогда
			ПромСтр = Сред(ПромСтр,2);
		КонецЕсли;
		Если Прав(ПромСтр,1) = "'" Тогда
			ПромСтр = Лев(ПромСтр,СтрДлина(ПромСтр)-1);
		КонецЕсли;
		
		//ПромСтр = СтрЗаменить(ПромСтр,"\\","\");
		
		ПараметрыСтроки.Добавить(ПромСтр);
		//Сообщить("Item.Value строка = " + Item.Value);
	КонецЦикла;
	
	стр=RegExp.Replace(стр, " <ПараметрСтрока> "); 
	
	//Сообщить("стр="+стр);
	
	
	
	//найдём параметры даты
	RegExp.Pattern = "\d\d\.\d\d\.(\d\d\d\d|\d\d)"; 
	ПараметрыRegExp=RegExp.Execute(стр); 
	Для i=0 По ПараметрыRegExp.Count-1 Цикл
		Item = ПараметрыRegExp.Item(i);
		ПараметрыДаты.Добавить(Item.Value);
		//Сообщить("Item.Value дата = " + Item.Value);
	КонецЦикла;
	стр=RegExp.Replace(стр, " <ПараметрДата> "); 
	
	//Сообщить("стр="+стр);
	
	
	
	//найдём параметры числа
	//RegExp.Pattern = "\d+"; 
	//RegExp.Pattern = "[-+]?\b[0-9]*\.?[0-9]+\b"; 
	RegExp.Pattern = "(^)*([^\wа-яё+-\.][-+]?[0-9]+(\.[0-9]+)?)";
	//RegExp.Pattern = "/^-{0,1}\d+\.{0,1}\d*$/"; 
	ПараметрыRegExp=RegExp.Execute(стр); 
	Для i=0 По ПараметрыRegExp.Count-1 Цикл
		Item = ПараметрыRegExp.Item(i);
		ПараметрыЧисла.Добавить(Item.Value);
		//Сообщить("Item.Value число = " + Item.Value);
	КонецЦикла;
	стр=RegExp.Replace(стр, " <ПараметрЧисло> "); 
	
	//Сообщить("стр="+стр);
	
	
	УбратьЗапрещенныеСимволыИзStepDefinition(стр);
	//стр = СтрЗаменить(Стр,":","");//надо убрать некоторые спец символы
	
	
	
	//разделим на слова
	//в VBScript нет метода Split, поэтому сделаем иначе
	RegExp.Pattern = "\s+"; 
	ПромСтр=RegExp.Replace(стр,"+|||+"); 
	//Сообщить("ПромСтр="+ПромСтр);
	
	МассивПодстрок = РазложитьСтрокуВМассивПодстрок(ПромСтр,"+|||+",Истина);
	КолПараметров       = 0;
	КолПараметровЧисло  = 0;
	КолПараметровСтрока = 0;
	КолПараметровДата   = 0;
	СтрокаПараметров = "";
	Для Каждого Элем Из МассивПодстрок Цикл
		//Сообщить("Элем="+Элем);
		Если Элем = "<ПараметрСтрока>" Тогда
			КолПараметров       = КолПараметров       + 1;
			КолПараметровСтрока = КолПараметровСтрока + 1;
			
			СтрокаПараметров = СтрокаПараметров + ДобавитьПараметрStepDefinition(Элем,КолПараметров);
			//Сообщить("ПараметрыСтроки[КолПараметровСтрока-1]=" + ПараметрыСтроки[КолПараметровСтрока-1]);
			args             = args + "{""val"":""{" + ПараметрыСтроки[КолПараметровСтрока-1] + "}""}" + ",";
			Продолжить;
		КонецЕсли;
		Если Элем = "<ПараметрЧисло>" Тогда
			КолПараметров      = КолПараметров      + 1;
			КолПараметровЧисло = КолПараметровЧисло + 1;
			
			СтрокаПараметров = СтрокаПараметров + ДобавитьПараметрStepDefinition(Элем,КолПараметров);
			args             = args + "{""val"":""{" + ПараметрыЧисла[КолПараметровЧисло-1] + "}""}" + ",";
			Продолжить;
		КонецЕсли;
		Если Элем = "<ПараметрДата>" Тогда
			КолПараметров      = КолПараметров      + 1;
			КолПараметровДата  = КолПараметровДата  + 1;
			
			СтрокаПараметров = СтрокаПараметров + ДобавитьПараметрStepDefinition(Элем,КолПараметров);
			args             = args + "{""val"":""{" + ПараметрыДаты[КолПараметровДата-1] + "}""}" + ",";
			Продолжить;
		КонецЕсли;
		
		StepDefinition = StepDefinition + СделатьПервуюБуквуЗаглавной(Элем);
	КонецЦикла;
	Если СтрокаПараметров <> "" Тогда
		СтрокаПараметров = Лев(СтрокаПараметров,СтрДлина(СтрокаПараметров)-1);//там лишняя запятая
	КонецЕсли;
	
	УбратьЗапрещенныеСимволыИзStepDefinition(StepDefinition);

	StepDefinition = StepDefinition + "(" + СтрокаПараметров + ")";
	
	Если СтрДлина(args) > 0 Тогда
		args = Лев(args,СтрДлина(args)-1);//убрали запятую
	КонецЕсли;
	//Сообщить("args="+args);
	
	
	Возврат StepDefinition;
	//Сообщить(стр);
КонецФункции

&НаКлиенте
Функция Это_begin_scenario_tags(Знач Стр,ИмяФ,ПутьКФ) Экспорт
	СтрПоиска = "[""begin_scenario"",{""tags"":[""";
	Если Лев(Стр,СтрДлина(СтрПоиска)) = СтрПоиска Тогда
		Стр = СокрЛП(Сред(Стр,СтрДлина(СтрПоиска)+1));
		//Сообщить("ПолезноеЗначение1="+ПолезноеЗначение);
		Стр = Лев(Стр,СтрДлина(Стр)-4);
		Поз = Найти(Стр,";");
		Стр1 = Лев(Стр,Поз-1);
		ИмяФ = СтрЗаменить(Стр1,"[ИмяФичи]=","");
		ПутьКФ = Сред(Стр,Поз+1);
		ПутьКФ = СтрЗаменить(ПутьКФ,"\\","\");
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции


&НаКлиенте
Процедура ВызватьМетод(Обработка, ИмяПроцедуры, МассивАргументов);
	Команда = "Обработка." + ИмяПроцедуры + "(";
	
	Для Ккк = 0 По МассивАргументов.Количество()-1 Цикл
		Элем = МассивАргументов[Ккк];
		Команда = Команда + Элем;
		Если Ккк < МассивАргументов.Количество()-1 Тогда
			Команда = Команда + ",";
		КонецЕсли;	 
	КонецЦикла;
	
	Команда = Команда + ")";
	
	Отладка("Выполняю: " + Команда);
	Выполнить(Команда);
КонецПроцедуры


&НаКлиенте
Функция СформироватьОписаниеОшибки(Знач Стр,ИмяФайла,ИмяПроцедуры) Экспорт
	Стр = СтрЗаменить(Стр,Символы.ПС,"");
	Стр = СтрЗаменить(Стр,Символы.ВК,"");
	
	СтрПоиска = "Рефлектор.ВызватьМетод(СтрТаблицаКонтекстовОбработок.Обработка, ИмяПроцедуры, МассивАргументов);";
	Поз = Найти(Стр,СтрПоиска);
	Если Поз > 0 Тогда
		ПромСтр = Сред(Стр,Поз + СтрДлина(СтрПоиска));
		Если ПромСтр <> "" Тогда
			Стр = ПромСтр;
		КонецЕсли;
	КонецЕсли;
	
	Поз1 = Найти(Стр,"Метод объекта не обнаружен");
	Если Поз1 > 0 Тогда
		Стр = Сред(Стр,Поз1);
		Поз2 = Найти(Стр,")");
		Стр = Лев(Стр,Поз2);
	КонецЕсли;
	//Стр = СтрЗаменить(Стр,СтрПоиска,"");
	
	Стр = Стр + "; ИмяФайла="+СтрЗаменить(ИмяФайла,"\","\\") + ", ИмяПроцедуры="+ИмяПроцедуры;
	//Возврат ПерекодировкаДляОтправкиОшибки(Стр);
	Возврат Стр;
КонецФункции

&НаКлиенте
Функция НайтиСозданнуюОбработку(ИмяФайла)
	Если ЭтоУФ Тогда
		ИД = МассивИменФайлов.Найти(ИмяФайла);
		Если ИД = Неопределено Тогда
			СделатьСообщение("Ошибка! В НайтиСозданнуюОбработку не найден контекст обработки " + ИмяФайла);
			ВызватьИсключение "Ошибка! В НайтиСозданнуюОбработку не найден контекст обработки " + ИмяФайла;
		КонецЕсли;	 
		
		Возврат МассивКонтекстовОбработок[ИД];
	КонецЕсли;	 
КонецФункции


&НаКлиенте
Функция ВыполнитьПроцедуруОбработки(ИмяФайла,ИмяПроцедуры,ПараметрыОбработки = Неопределено);
	DebugLog = Объект.DebugLog;
	//Сообщить("""ВыполнитьПроцедуруОбработки"" не реализована!");
	//ВызватьИсключение """ВыполнитьПроцедуруОбработки"" не реализована!";
	
	
	
	
	
	СтрокаВозврата = "[""success""]";
	
	
	//Рефлектор = Новый Рефлектор();
	//Рефлектор = "";
	МассивАргументов = Новый Массив;
	Если ПараметрыОбработки <> Неопределено Тогда
		МассивАргументов = ПараметрыОбработки;
	КонецЕсли;
	
	
	
	Обработка = НайтиСозданнуюОбработку(ИмяФайла);
	
	//СтрТаблицаКонтекстовОбработок = ТаблицаКонтекстовОбработок.Найти(ИмяФайла,"ИмяФайла");
	//Если СтрТаблицаКонтекстовОбработок = Неопределено Тогда
	//	ПрерватьВыполнениеСкрипта("В таблице ТаблицаКонтекстовОбработок не найден файл " + ИмяФайла);
	//КонецЕсли;
	
	Попытка
		
		Если ЭтоУФ Тогда
			Обработка.Контекст = ОбъектКонтекст;
			ВызватьМетод(Обработка, ИмяПроцедуры, МассивАргументов);
			ОбъектКонтекст = Обработка.Контекст;
		Иначе	
			Обработка.Контекст = ОбъектКонтекст;
			ВызватьМетод(Обработка, ИмяПроцедуры, МассивАргументов);
			ОбъектКонтекст = Обработка.Контекст;
		КонецЕсли;	 
	Исключение
		Отладка("ОписаниеОшибки()="+ОписаниеОшибки());
		ОписаниеОшибкиСтр = ОписаниеОшибки();
		Если Найти(ОписаниеОшибкиСтр,"}: Не реализовано.") > 0 Тогда //тогда это Pending
			СтрокаВозврата = "[""pending"", ""I'll do it later""]";
		Иначе
			//значит возникла ошибка
			СтрОшибка = СформироватьОписаниеОшибки(ОписаниеОшибки(),ИмяФайла,ИмяПроцедуры);
			СделатьСообщение(СтрОшибка);
			СтрОшибка = ПерекодировкаДляОтправкиОшибки(СтрОшибка);
			СтрокаВозврата = "[""fail"",{""message"":""" + СтрОшибка + """}]";
		КонецЕсли;
	КонецПопытки;
	
	//СтрокаВозврата = СтрЗаменить(СтрокаВозврата,Символы.ПС,"");
	//СтрокаВозврата = СтрЗаменить(СтрокаВозврата,Символы.ВК,"");
	
	//Поз = Найти(СтрокаВозврата,Символы.ПС);
	//Если Поз > 0 Тогда
	//	Сообщить("Обнаружен перевод строки.");
	//КонецЕсли;
	
	Возврат СтрокаВозврата;
КонецФункции



&НаКлиенте
Функция Это_end_scenario_tags(Знач Стр) Экспорт
	СтрПоиска = "[""end_scenario"",{""tags"":[""";
	Если Лев(Стр,СтрДлина(СтрПоиска)) = СтрПоиска Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции


&НаКлиенте
Функция Это_invoke(Знач Стр,ИмяМетода,ЗначенияПараметров) Экспорт
	СтрПоиска = "[""invoke"",{""id"":""";
	Если Лев(Стр,СтрДлина(СтрПоиска)) = СтрПоиска Тогда
		Стр = СокрЛП(Сред(Стр,СтрДлина(СтрПоиска)+1));
		//Сообщить("Стр="+Стр);
		
		СтрПоиска2 = """args"":[";
		Поз = Найти(Стр,СтрПоиска2);
		ИмяМетода = Лев(Стр,Поз-3);
		ЗначенияПараметров = Сред(Стр,Поз+СтрДлина(СтрПоиска2)-1);
		ЗначенияПараметров = Лев(ЗначенияПараметров,СтрДлина(ЗначенияПараметров)-2);
		Отладка("ИмяМетода="+ИмяМетода);
		Отладка("ЗначенияПараметров="+ЗначенияПараметров);
		
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции

&НаСервере
Функция ПолучитьСтруктураStepDefinition(ИмяМетода)
	ТзнТаблицаИзвестныхStepDefinition = РеквизитФормыВЗначение("ТаблицаИзвестныхStepDefinition");
	
	
	СтрТаблицаИзвестныхStepDefinition = ТзнТаблицаИзвестныхStepDefinition.Найти(ИмяМетода,"ID");
	Если СтрТаблицаИзвестныхStepDefinition = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;	 
	
	СтруктураВозврата = Новый Структура;
	СтруктураВозврата.Вставить("ИмяФайла",СтрТаблицаИзвестныхStepDefinition.ИмяФайла);
	СтруктураВозврата.Вставить("Id",СтрТаблицаИзвестныхStepDefinition.Id);
	СтруктураВозврата.Вставить("СтрокаРеальнойПроцедуры",СтрТаблицаИзвестныхStepDefinition.СтрокаРеальнойПроцедуры);
	СтруктураВозврата.Вставить("Параметры",СтрТаблицаИзвестныхStepDefinition.Параметры);
	
	Возврат СтруктураВозврата;
КонецФункции


&НаКлиенте
Функция ПреобразоватьКДатеСтроку(Знач Стр) Экспорт
	НачСтр = Стр;
	//Зн = Дата(Стр);
	Год   = 0;
	Месяц = 0;
	День  = 0;
	
	Поз  = Найти(Стр,".");
	День = Число(Лев(Стр,Поз-1));
	Стр = Сред(Стр,Поз+1);
	
	Поз   = Найти(Стр,".");
	Месяц = Число(Лев(Стр,Поз-1));
	Стр   = Сред(Стр,Поз+1);
	
	Год   = Число(Стр);
	Если Год < 100 Тогда
		Год = Год + 2000;
	КонецЕсли;
	
	Зн = Дата(Год,Месяц,День);
	
	Зн = Формат(Зн,"ДФ=yyyyMMdd");
	Зн = "'" + Зн + "'";
	
	//Отладка("" + НачСтр + " было преобразовано к " + Зн);
	Возврат Зн;
КонецФункции


&НаКлиенте
Функция РазобратьСтрокуЗначенийПараметров(Знач Стр,ПараметрыСвойства) Экспорт
	Массив = Новый Массив;
	
	Если Лев(Стр,1) = "[" Тогда
		Стр = Сред(Стр,2);
	КонецЕсли;
	Если Прав(Стр,1) = "]" Тогда
		Стр = Лев(Стр,СтрДлина(Стр)-1);
	КонецЕсли;
	//Сообщить("Стр="+Стр);
	
	
	ИдПараметра = 0;
	
	Пока Истина Цикл
		Поз1 = Найти(Стр, """{");
		Если Поз1 = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Поз2 = Найти(Стр, "}""");
		Если Поз2 = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Зн = Сред(Стр,Поз1+2,Поз2-Поз1-2);
		//Сообщить("Зн="+Зн);
		Тип = ПараметрыСвойства[ИдПараметра].Тип;
		//Сообщить("Тип="+Тип + ", ИдПараметра=" + ИдПараметра);
		
		Стр = Сред(Стр,Поз2+1+2);
		//Сообщить("Новая Стр="+Стр);
		//Прервать;
		
		
		Если Тип = "Число" Тогда
			Попытка
				//Зн = Число(Зн);
			Исключение
				ВызватьИсключение ("Не смог преобразовать к числу. Значение="+Зн + ", СтрокаПараметров="+Стр);
			КонецПопытки;
		КонецЕсли;
		
		Если Тип = "Дата" Тогда
			Попытка
				Зн = ПреобразоватьКДатеСтроку(Зн);
			Исключение
				ВызватьИсключение ("Не смог преобразовать к дате. Значение="+Зн + ", СтрокаПараметров="+Стр);
			КонецПопытки;
		КонецЕсли;
		
		
		Если Тип = "Строка" Тогда
			Зн = """" + Зн + """"; //добавим кавычки
		КонецЕсли;
		
		Массив.Добавить(Зн);
		ИдПараметра = ИдПараметра + 1;
	КонецЦикла;
	
	Возврат Массив;
КонецФункции


&НаКлиенте
Функция СделатьInvoke(ИмяМетода,ЗначенияПараметров)
	СтрокаВозврата = "";
	
	
	//Сообщить("Invoke: ИмяМетода=" + ИмяМетода);
	//Сообщить("Invoke: ЗначенияПараметров=" + ЗначенияПараметров);
	
	//Сообщить("""СделатьInvoke"" не реализован!");
	//ВызватьИсключение """СделатьInvoke"" не реализован!";
	
	СтруктураStepDefinition = ПолучитьСтруктураStepDefinition(ИмяМетода);
	Если СтруктураStepDefinition = Неопределено Тогда
		СтрокаВозврата = СтрокаВозврата = "[""fail"",{""message"":""" + "В epf файлах фич не обнаружен снипет:" + ИмяМетода + """}]";
		Возврат СтрокаВозврата;
	КонецЕсли;
	
	МассивПараметров = РазобратьСтрокуЗначенийПараметров(ЗначенияПараметров,СтруктураStepDefinition.Параметры);
	//Сообщить(СтрТаблицаИзвестныхStepDefinition.ИмяФайла);
	//в этом файле мы будем запускать данный шаг
	
	СтрокаРеальнойПроцедуры = СтруктураStepDefinition.СтрокаРеальнойПроцедуры;
	Поз = Найти(СтрокаРеальнойПроцедуры,"(");
	Если Поз > 0 Тогда
		СтрокаРеальнойПроцедуры = Лев(СтрокаРеальнойПроцедуры,Поз-1);
	КонецЕсли;
	
	СтрокаВозврата = ВыполнитьПроцедуруОбработки(СтруктураStepDefinition.ИмяФайла,СтрокаРеальнойПроцедуры,МассивПараметров);
	
	Возврат СтрокаВозврата;
КонецФункции


&НаСервере
Процедура ДобавитьStepDefinitionВТекстМодуля(СтруктураОписанияEpf,StepDefinition,ПримерИспользованияПроцедуры,ШагСтрокДляМодуля,ГенерироватьУФ,ЭтоУФ = Истина)
	Объект1 = РеквизитФормыВЗначение("Объект");
	Объект1.ДобавитьStepDefinitionВТекстМодуля(СтруктураОписанияEpf,StepDefinition,ПримерИспользованияПроцедуры,ШагСтрокДляМодуля,ГенерироватьУФ,ЭтоУФ);
КонецПроцедуры


&НаКлиенте
Функция ОбработатьПараметрыВызоваBDD(СтрокаВызова)
	TestRun        = Объект.TestRun;
	GenerateEpf    = Объект.GenerateEpf;
	КаталогИнструментов = Объект.КаталогИнструментов;
	КаталогФич     = Объект.КаталогФич;
	DebugLog       = Объект.DebugLog;
	ГенерироватьУФ = Объект.ГенерироватьУФ;
	//Если DebugLog Тогда
	//	ЗаписатьВЖурнал("INFO", "Получен вызов BDD:" + СтрокаВызова);
	//КонецЕсли;	
	
	СтрокаВозврата = "[""success""]";
	//СтрокаВозврата = "[""success"",[{""id"":""1"", ""args"":[]}]]";
	
	StepDefinition               = "";
	ПолезноеЗначение             = "";
	ПримерИспользованияПроцедуры = "";
	ПромСтр = СтрокаВызова;
	Если Это_step_matches_name_to_match(ПромСтр,ПолезноеЗначение) Тогда
		//Сообщить("ПолезноеЗначение="+ПолезноеЗначение);
		args = "";
		//Сообщить("ПолезноеЗначение=" + ПолезноеЗначение);
		Если Найти(ПолезноеЗначение,"[") > 0 Тогда
			ПрерватьВыполнениеСкрипта("Не верное определение имени фичи: " + ПолезноеЗначение);
		КонецЕсли;
		StepDefinition = ПолучитьStepDefinition(ПолезноеЗначение,args);
		ПримерИспользованияПроцедуры   = ПолезноеЗначение;
		Отладка("StepDefinition="+StepDefinition);
		
		СтрокаВозврата = "[""success"",[{""id"":""" + StepDefinition + """, ""args"":[" + args +"]}]]";
	КонецЕсли;
	
	ИмяФ                     = "";
	ОтносительныйКаталогФичи = "";
	ПромСтр                  = СтрокаВызова;
	Если Это_begin_scenario_tags(ПромСтр,ИмяФ,ОтносительныйКаталогФичи) Тогда
		Если ИмяТекущейФичи <> ИмяФ Тогда
			
			Если TestRun Тогда
				//если мы в режиме генерации, то глобальная переменная ИмяТекущейФичи уже была инициализирована в таймере "ТаймерДляГенерацииФич"
				ИмяТекущейФичи = ИмяФ;
			КонецЕсли;	
			
			Если TestRun Тогда
				ОбъектКонтекст = Новый Структура;//контекст один на всю фичу, а не на весь сценарий (в фиче может быть много сценариев)
				ОбъектКонтекст.Вставить("КаталогИнструментов",КаталогИнструментов);
				ОбъектКонтекст.Вставить("КаталогФич",КаталогФич);
				
				СоздатьИлиДополнитьСтруктурыДляEpfФайлов(ОтносительныйКаталогФичи);
			КонецЕсли;
		КонецЕсли;
		
		
		//СтрокаВозврата = "[""success""]";
		Если TestRun Тогда
			Если ИмяТекущейФичи = "" Тогда
				ПрерватьВыполнениеСкрипта("Ошибка в Это_begin_scenario_tags! Переменная ""ИмяТекущейФичи"" не заполнена!");
			КонецЕсли;	 
			СтруктураОписанияEpf = НайтиФичуВМассиве(ИмяТекущейФичи);
			СостояниеИдетInvoke = Истина;
			СтрокаВозврата = ВыполнитьПроцедуруОбработки(СтруктураОписанияEpf.ИмяФайлаEpf,"ПередНачаломСценария");
			СостояниеИдетInvoke = Ложь;
		КонецЕсли;
		Отладка("ИмяТекущейФичи="+ИмяТекущейФичи + ", ОтносительныйКаталогФичи="+ОтносительныйКаталогФичи);
	КонецЕсли;
	
	ПромСтр = СтрокаВызова;
	Если Это_end_scenario_tags(ПромСтр) Тогда
		Если TestRun Тогда
			СтруктураОписанияEpf = НайтиФичуВМассиве(ИмяТекущейФичи);
			СостояниеИдетInvoke = Истина;
			СтрокаВозврата = ВыполнитьПроцедуруОбработки(СтруктураОписанияEpf.ИмяФайлаEpf,"ПередОкончаниемСценария");
			СостояниеИдетInvoke = Ложь;
		КонецЕсли;
		//СтрокаВозврата = "[""success""]";
	КонецЕсли;
	
	ПромСтр            = СтрокаВызова;
	ИмяМетода          = "";
	ЗначенияПараметров = "";
	Если Это_invoke(ПромСтр,ИмяМетода,ЗначенияПараметров) Тогда
		Если TestRun Тогда
			СостояниеИдетInvoke = Истина;
			СтрокаВозврата = СделатьInvoke(ИмяМетода,ЗначенияПараметров);
			СостояниеИдетInvoke = Ложь;
		Иначе
			СтрокаВозврата = "[""pending"", ""I'll do it later""]";
		КонецЕсли;
	КонецЕсли;
	
	//Возврат "[""error1"",[]]";
	//СтрокаВозврата = "qqq";
	Отладка("СтрокаВозврата="+СтрокаВозврата);
	Отладка(" ");
	//sleep(1500);
	
	Если GenerateEpf Тогда
		//СоздатьИлиДополнитьСтруктурыДляEpfФайлов(StepDefinition,ПримерИспользованияПроцедуры,ОтносительныйКаталогФичи);
		Если StepDefinition <> "" Тогда
			Если ИмяТекущейФичи = "" Тогда
				ПрерватьВыполнениеСкрипта("Ошибка! Переменная ""ИмяТекущейФичи"" не заполнена!");
			КонецЕсли;	 
			СтруктураОписанияEpf = НайтиФичуВМассиве(ИмяТекущейФичи);
			//ТелоМодуля = СтруктураОписанияEpf.ТелоМодуля;
			ДобавитьStepDefinitionВТекстМодуля(СтруктураОписанияEpf,StepDefinition,ПримерИспользованияПроцедуры,ШагСтрокДляМодуля,ГенерироватьУФ);
			ПоложитьТелоМодуляВСтруктураОписанияEpf(ИмяТекущейФичи,СтруктураОписанияEpf);
			//СтруктураОписанияEpf.ТелоМодуля = ТелоМодуля;
			//Сообщить(ТелоМодуля);
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтрокаВозврата;
КонецФункции


&НаКлиенте
Процедура WinSocketDataArrival(bytesTotal)
	
 	ТкстСообщения = "";
    WinSocket.GetData(ТкстСообщения);
	//Сообщить("1. " + ТкстСообщения);
	ТкстСообщения = Перекодировка(ТкстСообщения);
	СделатьСообщение("Обработка сообщения: " + ТкстСообщения);
	
	
	Приостановить(400);
	
	Результат = ОбработатьПараметрыВызоваBDD(ТкстСообщения);
	
	ЧтоВернем = Результат + Символы.ПС;
	WinSocket.SendData(ЧтоВернем);
	
	
	КолСекундПростоя = 0;
	//ПодключитьОбработчикОжидания("Таймер",1);
КонецПроцедуры

&НаКлиенте
Процедура WinSocketConnect()
	Отладка("Покдлючение к " + WinSocket.RemoteHost + " успешно.");
КонецПроцедуры

&НаКлиенте
Процедура WinSocketConnectionRequest(requestID)
	Отладка("Запрос подключения");

    Сост = "Подключение";

    Если НЕ WinSocket.State = 0 Тогда
        WinSocket.Close()
    КонецЕсли;

    WinSocket.Accept(requestID);

    Отладка("Приконнектился "+WinSocket.RemoteHostIP);
КонецПроцедуры

&НаКлиенте
Процедура WinSocketClose()
	Отладка("WinSocketClose");
КонецПроцедуры

&НаКлиенте
Функция СоздатьWinsock()
	Если WinSocket <> Неопределено Тогда
		Возврат Истина;
	КонецЕсли;	 
	
	Попытка	
		WinSocket = Новый COMОбъект("mswinsock.winsock"); 
	Исключение 
		СделатьСообщение("Не смог создать объект winsock.");
		СделатьСообщение(ОписаниеОшибки());
		Возврат Ложь;
	КонецПопытки; 
	
	WinSocket.RemoteHost = "127.0.0.1";
	WinSocket.LocalPort  = 54321;
	
	ДобавитьОбработчик WinSocket.Close, WinSocketClose; 
	ДобавитьОбработчик WinSocket.ConnectionRequest, WinSocketConnectionRequest; 
	ДобавитьОбработчик WinSocket.Connect, WinSocketConnect; 
	ДобавитьОбработчик WinSocket.DataArrival, WinSocketDataArrival; 
	ДобавитьОбработчик WinSocket.Error, WinSocketError; 
	//ДобавитьОбработчик WinSocket.SendComplete, SendComplete; 
	//ДобавитьОбработчик WinSocket.SendProgress, SendProgress; 
	
	Отладка("Создал winsock.");
	
	Возврат Истина
КонецФункции // ()
//часть WinSocket - конец



&НаКлиенте
Процедура Инициализация()
	ИмяТекущейФичи       = "";
	МассивДляСозданияEpf = Новый Массив;
	МассивНайденыхФич    = Новый Массив;
	ШагСтрокДляМодуля    = 1000;
	
	//ТаблицаИзвестныхStepDefinition = Новый ТаблицаЗначений;
	//ТаблицаИзвестныхStepDefinition.Колонки.Добавить("ИмяФайла");
	////ТаблицаИзвестныхStepDefinition.Колонки.Добавить("ТаблицаПроцедур");
	//ТаблицаИзвестныхStepDefinition.Колонки.Добавить("Id");
	//ТаблицаИзвестныхStepDefinition.Колонки.Добавить("СтрокаРеальнойПроцедуры");
	//ТаблицаИзвестныхStepDefinition.Колонки.Добавить("Параметры");
	
	//ТаблицаКонтекстовОбработок = Новый ТаблицаЗначений;
	//ТаблицаКонтекстовОбработок.Колонки.Добавить("ИмяФайла");
	//ТаблицаКонтекстовОбработок.Колонки.Добавить("Обработка");
	
	ТаблицаИзвестныхStepDefinition.Очистить();
	ТаблицаКонтекстовОбработок.Очистить();
	
	ОшибкаВнутриОбработкиВызоваBDD = Ложь;
	
	АргументыКоманднойСтроки = Новый Массив;
	
	КолСекундПростоя = 0;
	
	МассивКонтекстовОбработок = Новый Массив;
	МассивИменФайлов          = Новый Массив;
	
	СостояниеИдетInvoke    = Ложь;
	СостояниеИдетГенерация = Ложь;
	
КонецПроцедуры



&НаСервере
Функция УбратьКаталогПроекта(Путь,КаталогИнструментов)
	Объект1 = РеквизитФормыВЗначение("Объект");
	Возврат Объект1.УбратьКаталогПроекта(Путь,КаталогИнструментов);
КонецФункции


&НаКлиенте
Процедура ПроставитьТегВФичу(ПутьКФайлу) Экспорт
	Текст = Новый ЧтениеТекста;
	Текст.Открыть(ПутьКФайлу,"UTF-8");

	КаталогИнструментов = Объект.КаталогИнструментов;
	
	Файл = Новый Файл(ПутьКФайлу);
	Путь = Файл.Путь;
	Если Прав(Путь,1) = "\" Тогда
		Путь = Лев(Путь,СтрДлина(Путь)-1);
	КонецЕсли;	 
	ИмяФичи = "@[ИмяФичи]=" + Файл.ИмяБезРасширения + ";" + Путь;
	
	
	НадоПерезаписатьТег   = Ложь;
	УжеЕстьПравильныйТег  = Ложь;
	Пока Истина Цикл
		Стр = Текст.ПрочитатьСтроку();
		Если Стр = Неопределено Тогда
			Прервать;
		КонецЕсли;	 
		
		Если Лев(СокрЛП(Стр),1) = "@" Тогда 
			Если Найти(Стр,"[ИмяФичи]") > 0 Тогда 
				Если Стр <> ИмяФичи Тогда
					НадоПерезаписатьТег = Истина;
				Иначе
					УжеЕстьПравильныйТег = Истина;
				КонецЕсли;
				Прервать;
			КонецЕсли;	 
		КонецЕсли;	 
		
	КонецЦикла;
	Текст.Закрыть();
	
	Если УжеЕстьПравильныйТег Тогда
		Возврат;
	КонецЕсли;
	
	
	Текст = Новый ЧтениеТекста;
	Текст.Открыть(ПутьКФайлу,"UTF-8");
	
	ИмяТемпФайла = ПутьКФайлу + "Temp";
	УдалитьФайлы(ИмяТемпФайла);
	
	ЗТ = Новый ЗаписьТекста(ИмяТемпФайла,"UTF-8",,Истина); 
	
	ДобавитьТегСледующейСтрокой = Ложь;
	УжеЗаписывалТег             = Ложь;
	Пока Истина Цикл
		Стр = Текст.ПрочитатьСтроку();
		Если Стр = Неопределено Тогда
			Прервать;
		КонецЕсли;	 
		
		Если НадоПерезаписатьТег Тогда 
			Если Лев(СокрЛП(Стр),1) = "@" Тогда 
				Если Найти(Стр,"[ИмяФичи]") > 0 Тогда 
					//Файл = Новый Файл(ПутьКФайлу);
					Стр = ИмяФичи;
				КонецЕсли;	 
			КонецЕсли;	 
		Иначе	
			Если (Лев(СокрЛП(Стр),1) <> "#") и (СтрДлина(СокрЛП(Стр)) > 0) Тогда 
				ДобавитьТегСледующейСтрокой = Истина;
			КонецЕсли;	
		КонецЕсли;	 
		
		
		Если ДобавитьТегСледующейСтрокой и (Не УжеЗаписывалТег) Тогда 
			//Файл = Новый Файл(ПутьКФайлу);
			СтрФича = ИмяФичи;
			ЗТ.Записать(СтрФича); 
			ЗТ.Записать(Символы.ПС); 
			ЗТ.Записать(Символы.ПС); 
			
			ДобавитьТегСледующейСтрокой = Ложь;
			УжеЗаписывалТег = Истина;
		КонецЕсли;	 
		
		ЗТ.Записать(Стр); 
		ЗТ.Записать(Символы.ПС); 
	КонецЦикла;
	
	ЗТ.Закрыть();
	Текст.Закрыть();
	УдалитьФайлы(ПутьКФайлу);
	ПереместитьФайл(ИмяТемпФайла,ПутьКФайлу);
	
КонецПроцедуры

&НаКлиенте
Процедура ОбработатьFeatureФайлыЧтобыПроставитьТегиСИменемФичиИЗаполнитьМассивНайденыхФич(НачальныйКаталог)
	//Сообщить("НачальныйКаталог= " + НачальныйКаталог);
	
	КаталогПоиска = НачальныйКаталог;
	Файл = Новый Файл(КаталогПоиска);
	Если НЕ Файл.ЭтоКаталог() Тогда //передали сразу одну фичу
		ПроставитьТегВФичу(Файл.ПолноеИмя);
	КонецЕсли;	 
	МассивФайлов = НайтиФайлы(КаталогПоиска,"*.feature",Истина);
	Для Каждого Элем Из МассивФайлов Цикл
		//Сообщить("Найден файл " + Элем.Имя);
		ПроставитьТегВФичу(Элем.ПолноеИмя);
		
		СтруктураФичи = Новый Структура;
		СтруктураФичи.Вставить("ИмяФичи",Элем.ИмяБезРасширения);
		СтруктураФичи.Вставить("ПолныйПуть",Элем.Путь);
		
		//Стр = СтрЗаменить(СтруктураФичи.ПолныйПуть,КаталогИнструментов);
		
		
		МассивНайденыхФич.Добавить(СтруктураФичи);
	КонецЦикла;
КонецПроцедуры

&НаСервере
Функция ПолучитьКаталогФич(СтрКаталогПроекта,СтрКаталогФич)
	Объект1 = РеквизитФормыВЗначение("Объект");
	Возврат Объект1.ПолучитьКаталогФич(СтрКаталогПроекта,СтрКаталогФич);
КонецФункции


&НаКлиенте
Процедура АнализЛогаКукумбера(ИмяФайла,БылиОшибкиЗапускаКукумбера)
	Файл = Новый Файл(ИмяФайла);
	Если Не Файл.Существует() Тогда
		БылиОшибкиЗапускаКукумбера = Истина;
		СделатьСообщение("Не найден файл " + ИмяФайла);
		Возврат;
	КонецЕсли;

	Текст = Новый ЧтениеТекста;
	Попытка
		Текст.Открыть(ИмяФайла,"UTF-8");
	Исключение
		СделатьСообщение("Не смог открыть лог кукумбера на чтение!");
		СделатьСообщение(ОписаниеОшибки());
		Возврат;
	КонецПопытки;
	
	НайденаОшибка = Ложь;
	Пока Истина Цикл
		Стр = Текст.ПрочитатьСтроку();
		Если Стр = Неопределено Тогда
			Прервать;
		КонецЕсли;	 
		
		Если НРег(Лев(Стр,12)) = НРег("*** WARNING:") Тогда
			Продолжить;
		КонецЕсли;
	
		БылиОшибкиЗапускаКукумбера = Истина;
		СделатьСообщение("Обнаружена ошибка Cucumber.");
		СделатьСообщение(Стр);
		НайденаОшибка = Истина;
		Прервать;// ошибка содержится в первой строке
	КонецЦикла;	
	
	Текст.Закрыть();
	
	Если Не НайденаОшибка Тогда
		СделатьСообщение("Ошибок в логе Cucumber не найдено.");
	КонецЕсли;	 
КонецПроцедуры

&НаКлиенте
Процедура СоздатьКаталогЕслиЕгоНет(Путь)
	Файл = Новый Файл(Путь);
	Если Путь = "" Тогда
		СделатьСообщение("Передан пустой путь в процедуру ""СоздатьКаталогЕслиЕгоНет""!");
		ВызватьИсключение "Передан пустой путь в процедуру ""СоздатьКаталогЕслиЕгоНет""!";
	КонецЕсли;	 
	Если Не Файл.Существует() Тогда
		СоздатьКаталог(Путь);
		Отладка("Создан каталог: " + Путь);
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ЗаменитьСтрокиВФайлеОсновыОбработки(ИмяФайлОсноваОбработки,ИмяФичи)
	Текст = Новый ЧтениеТекста;
	Текст.Открыть(ИмяФайлОсноваОбработки,"UTF-8");

	
	ВременноеИмяФайла = ИмяФайлОсноваОбработки + "_Temp";
	ЗТ = Новый ЗаписьТекста(ВременноеИмяФайла,"UTF-8",,Истина); 
	
	Пока Истина Цикл
		Стр = Текст.ПрочитатьСтроку();
		Если Стр = Неопределено Тогда
			Прервать;
		КонецЕсли;	 
		
		Стр = СтрЗаменить(Стр,"TemplateEpf",ИмяФичи);
		Стр = СтрЗаменить(Стр,"Template epf",ИмяФичи);
		
		ЗТ.ЗаписатьСтроку(Стр); 
	КонецЦикла;
	
	ЗТ.Закрыть();
	Текст.Закрыть();
	Текст = "";
	Приостановить(500);
	
	УдалитьФайлы(ИмяФайлОсноваОбработки);
	ПереместитьФайл(ВременноеИмяФайла,ИмяФайлОсноваОбработки);
	
КонецПроцедуры

&НаСервереБезКонтекста
Функция ПолучитьТелоМодуляВМассивСервер(Стр)
	Тзн = ЗначениеИзСтрокиВнутр(Стр);
	Тзн.Сортировать("НомСтр");
	Возврат Тзн.ВыгрузитьКолонку("Стр");
КонецФункции

&НаКлиенте
Процедура СоздатьФайлыОбработок(БылиОшибки)
	КаталогИнструментов = Объект.КаталогИнструментов;
	ГенерироватьУФ = Объект.ГенерироватьУФ;
		
	Для Каждого СтруктураОписанияEpf Из МассивДляСозданияEpf Цикл
		ТелоМодуля = СтруктураОписанияEpf.ТелоМодуля;
		Если ЭтоУФ Тогда
			ТелоМодуля = ПолучитьТелоМодуляВМассивСервер(ТелоМодуля);
		Иначе
			ТелоМодуля.Сортировать("НомСтр");
			ТелоМодуля = ТелоМодуля.ВыгрузитьКолонку("Стр");
		КонецЕсли;	 
		
		Отладка("Буду записывать " + СтруктураОписанияEpf.ВременноеИмяМодуля);
		
		//Продолжить;
		
		УдалитьФайлы(СтруктураОписанияEpf.ВременноеИмяМодуля);
		Если ГенерироватьУФ Тогда
			ИмяФайлаФормаУФ = КаталогИнструментов + "\lib\TemplateEpfUF\und\70e297e0-e8a2-43bf-8be1-62e408f610a1.0_template";
			//тут свой собственный файл
			
			
			Текст = Новый ЧтениеТекста;
			Текст.Открыть(ИмяФайлаФормаУФ,"UTF-8");
			
			ЗТ = Новый ЗаписьТекста(СтруктураОписанияEpf.ВременноеИмяМодуля,"UTF-8",,Истина); 
			
			Пока Истина Цикл
				Стр = Текст.ПрочитатьСтроку();
				Если Стр = Неопределено Тогда
					Прервать;
				КонецЕсли;	 
				
				ЗТ.ЗаписатьСтроку(Стр); 
				
				Если Стр = "},""//начало текста модуля" Тогда
					Для Каждого СтрТелоМодуля Из ТелоМодуля Цикл
						Если СокрЛП(СтрТелоМодуля) = "//начало текста модуля" Тогда //это строка и так запишется из шаблона
							Продолжить;
						КонецЕсли;	 
						Если СокрЛП(СтрТелоМодуля) = "//окончание текста модуля" Тогда //это строка и так запишется из шаблона
							Продолжить;
						КонецЕсли;	 
						//СделатьСообщение("СтрТелоМодуля.Стр = " + СтрТелоМодуля.Стр);
						СтрТелоМодуля = СтрЗаменить(СтрТелоМодуля,"""","""""");
						ЗТ.ЗаписатьСтроку(СтрТелоМодуля); 
						//ЗТ.Записать(Символы.ПС); 
					КонецЦикла;
				КонецЕсли;	 
			КонецЦикла;	
			
			
			Текст.Закрыть();
			ЗТ.Закрыть();
		Иначе	
			ЗТ = Новый ЗаписьТекста(СтруктураОписанияEpf.ВременноеИмяМодуля,"UTF-8",,Истина); 
			Для Каждого СтрТелоМодуля Из ТелоМодуля Цикл
				//СделатьСообщение("СтрТелоМодуля.Стр = " + СтрТелоМодуля.Стр);
				ЗТ.ЗаписатьСтроку(СтрТелоМодуля); 
				//ЗТ.Записать(Символы.ПС); 
			КонецЦикла;
			ЗТ.Закрыть();
		КонецЕсли;	 
		Отладка("Записал " + СтруктураОписанияEpf.ВременноеИмяМодуля);
		
		ПутьКИсходникам = СтруктураОписанияEpf.КаталогИсходников;
		
		
		ИмяФайлаМодуляДляСборки = ПутьКИсходникам + "\ObjectModule.txt";
		Если ГенерироватьУФ Тогда
			ИмяФайлаМодуляДляСборки = ПутьКИсходникам + "\und\70e297e0-e8a2-43bf-8be1-62e408f610a1.0";
		КонецЕсли;	 
		
		УдалитьФайлы(ИмяФайлаМодуляДляСборки);
		ПереместитьФайл(СтруктураОписанияEpf.ВременноеИмяМодуля,ИмяФайлаМодуляДляСборки);
		Отладка("Переименовал в " + ИмяФайлаМодуляДляСборки);
		
		
		ИмяФайлОсноваОбработкиTemplate = ПутьКИсходникам + "\und\79a499cc-1782-4a2f-abe7-61ea4d49fd5a_template";
		ИмяФайлОсноваОбработки         = ПутьКИсходникам + "\und\79a499cc-1782-4a2f-abe7-61ea4d49fd5a";
		Если ГенерироватьУФ Тогда
			ИмяФайлОсноваОбработкиTemplate = ПутьКИсходникам + "\und\79a499cc-1782-4a2f-abe7-61ea4d49fd5a_template";
			ИмяФайлОсноваОбработки         = ПутьКИсходникам + "\und\79a499cc-1782-4a2f-abe7-61ea4d49fd5a";
		КонецЕсли;	 
		
		Файл_template = Новый Файл(ИмяФайлОсноваОбработкиTemplate);
		Если Файл_template.Существует() Тогда
			//это значит обработка создаётся в первый раз
			КопироватьФайл(ИмяФайлОсноваОбработкиTemplate,ИмяФайлОсноваОбработки);
			ЗаменитьСтрокиВФайлеОсновыОбработки(ИмяФайлОсноваОбработки,СтруктураОписанияEpf.ИмяФичи);
		КонецЕсли;	 
		
		
		Файл = Новый Файл(СтруктураОписанияEpf.ИмяФайлаEpf);
		СоздатьКаталогЕслиЕгоНет(Файл.Путь);
		
		Если Файл.Существует() Тогда
			УдалитьФайлы(Файл.ПолноеИмя);
		КонецЕсли;	 
		
		СделатьСообщение("Создаю " + СтруктураОписанияEpf.ИмяФайлаEpf);
		СтрокаСборкиEpf = "python " + КаталогИнструментов + "\vendor\precommit1c\pyv8unpack.py --compile """ +  ПутьКИсходникам  + """ """ + СтруктураОписанияEpf.ИмяФайлаEpf + """";
		//Если ГенерироватьУФ Тогда
		//	СтрокаСборкиEpf = "python " + КаталогИнструментов + "\vendor\precommit1c\pyv8unpack.py --compile " +  КаталогИнструментов + "\lib\TemplateEpfUF " + СтруктураОписанияEpf.ИмяФайлаEpf;
		//КонецЕсли;	 
		Отладка("СтрокаСборкиEpf="+СтрокаСборкиEpf);
		
		//retCode = "";
		//ЗапуститьПриложение(СтрокаСборкиEpf,,Истина,retCode);
		КомандаСистемы(СтрокаСборкиEpf);
		Если Файл.Существует() Тогда
			Отладка("Файл " + Файл.ПолноеИмя + " создан.");
		Иначе	
			СделатьСообщение("Ошибка создания файла " + Файл.ПолноеИмя + "!!!");
			БылиОшибки = Истина;
		КонецЕсли;	 
		//Сообщить("retCode=" + retCode);
		УдалитьФайлы(ИмяФайлаМодуляДляСборки);
		УдалитьФайлы(ИмяФайлОсноваОбработки);
		
	КонецЦикла;
	
КонецПроцедуры


&НаКлиенте
Процедура ТаймерОжиданияСеансаОбмена()
	КолСекундПростоя = КолСекундПростоя + 1;
	
	КаталогИнструментов                  = Объект.КаталогИнструментов;
	GenerateEpf                          = Объект.GenerateEpf;
	TestRun                              = Объект.TestRun;
	WinSocket1                           = WinSocket;
	ЗакрытьФормуПослеВыполненияОбработки = Объект.ЗакрытьФормуПослеВыполненияОбработки;
	
	//Если GenerateEpf Тогда
	//	Если КолСекундПростоя > 2 Тогда
	//		СостояниеИдетГенерация = Ложь;
	//	КонецЕсли;	 
	//КонецЕсли;	 
	
	//Сообщить("КолСекундПростоя="+КолСекундПростоя);
	
	Если GenerateEpf Тогда
		Если КолСекундПростоя >= 3 Тогда
			Если НЕ WinSocket1.State = 0 Тогда
				WinSocket1.Close()
			КонецЕсли;
			ОтключитьОбработчикОжидания("ТаймерОжиданияСеансаОбмена");
			СостояниеИдетГенерация = Ложь;
			
			СделатьСообщение("Обработка сообщений закончена.");
			КолСекундПростоя = 0;
			АнализЛогаКукумбера(КаталогИнструментов + "\CucumberConsolErr.txt",БылиОшибкиЗапускаКукумбера);
			Если Не БылиОшибкиЗапускаКукумбера Тогда
				БылиОшибки = Ложь;
				СоздатьФайлыОбработок(БылиОшибки);
				Если Не БылиОшибки Тогда
					СделатьСообщение("Ошибок при создании обработок не было.");
				Иначе	
					СделатьСообщение("Были ошибки при создании обработок.");
				КонецЕсли;	 
				Сообщить(" ");
			КонецЕсли;	 
			
			Если ЗакрытьФормуПослеВыполненияОбработки Тогда
				ЭтаФорма.Закрыть();
			КонецЕсли;	 
		КонецЕсли;	 
	КонецЕсли;	 
	
	Если TestRun Тогда
		Если СостояниеИдетInvoke Тогда
			КолСек = 180;
		Иначе
			КолСек = 3;
		КонецЕсли;	 
		
		Если КолСекундПростоя >= КолСек Тогда
			Если НЕ WinSocket1.State = 0 Тогда
				WinSocket1.Close()
			КонецЕсли;
			Если СостояниеИдетInvoke Тогда
				СостояниеИдетInvoke = Ложь;
				СделатьСообщение("Не дождался окончания выполнения шага. Остановка обработки по таймауту.");
			КонецЕсли;	 
			
			ОтключитьОбработчикОжидания("ТаймерОжиданияСеансаОбмена");
			СделатьСообщение("Обработка сообщений закончена.");
			КолСекундПростоя = 0;
			АнализЛогаКукумбера(КаталогИнструментов + "\CucumberConsolErr.txt",БылиОшибкиЗапускаКукумбера);
			
			
			СделатьСообщение("Запуск тестов закончен.");
			Если ЗакрытьФормуПослеВыполненияОбработки Тогда
				ЭтаФорма.Закрыть();
			КонецЕсли;	 
		КонецЕсли;	 
	КонецЕсли;	 
	//Сообщить("КолСекундПростоя = " + КолСекундПростоя);
КонецПроцедуры


&НаКлиенте
Процедура ЗапуститьСерверДляКукумбера(БылиОшибкиЗапускаКукумбера,ПереданноеИмяФичи = "")
	КаталогИнструментов = Объект.КаталогИнструментов;
	КаталогФич     = Объект.КаталогФич;
	Сервер = "";
	//Сервер = Новый TCPСервер(54321);
	//Сервер.Запустить();
	
	
	
	
	
	
	
	//Путь = "E:\commons\Rep\cuke4onec\cuke4onec.epf";
	//Путь = КаталогИнструментов + "\cuke4onec.epf";
	//cuke4onec = ОЛЕ.ExternalDataProcessors.Create(Путь);
	
	//StepsDir = "E:\commons\Rep\cuke4onec\features\step_definitions";
	//StepsDir = КаталогИнструментов + "\features\step_definitions";
	//cuke4onec._Create(StepsDir);
	//cuke4onec._Purge();
	
	//СтрокаЗапускаКукумбер = "Cucumber --dry-run --no-snippets """ + КаталогИнструментов + "\features"" > " + КаталогИнструментов + "\CucumberConsoleLog.txt";
	//СтрокаЗапускаКукумбер = "Cucumber --no-snippets  """ + КаталогИнструментов + "\features"" > " + КаталогИнструментов + "\CucumberConsoleLog.txt";
	//СтрокаЗапускаКукумбер = "Cucumber  --no-snippets """ + КаталогИнструментов + "\features""";
	
	
	//СтрокаЗапускаКукумбер = "Cucumber --no-snippets --no-color """ + КаталогИнструментов + "\features"" > " + КаталогИнструментов + //"\CucumberConsoleLog.txt" + " 2>" + КаталогИнструментов + "\CucumberConsolErr.txt";
	
	Если ПереданноеИмяФичи = "" Тогда
		ПараметрФича = ПолучитьКаталогФич(КаталогИнструментов,КаталогФич);
	Иначе
		ПараметрФича = ПереданноеИмяФичи;
	КонецЕсли;	 
	
	СтрокаЗапускаКукумбер = "cucumber --no-snippets -r " + КаталогИнструментов + "\host.wire """ + ПараметрФича + """ > " + КаталогИнструментов + "\CucumberConsoleLog.txt" + " 2>" + КаталогИнструментов + "\CucumberConsolErr.txt";
	//СтрокаЗапускаКукумбер = "cucumber """ + КаталогИнструментов + "\features"" ";

	WinSocket.Listen();
	ЗаписатьВЖурнал("INFO", "Жду соединения");

	Отладка("Строка для запуска Cucumber: " + СтрокаЗапускаКукумбер);
	УдалитьФайлы(Объект.КаталогИнструментов + "\CucumberConsolErr.txt");
	
	ИмяCmd = ПолучитьИмяВременногоФайла("cmd");
	УдалитьФайлы(ИмяCmd);
	ЗТ = Новый ЗаписьТекста(ИмяCmd,"windows-1251",,Истина); 
	ЗТ.ЗаписатьСтроку("chcp 1251"); 
	ЗТ.ЗаписатьСтроку(СтрокаЗапускаКукумбер); 
	ЗТ.Закрыть();
	
	
	
	КомандаСистемы("start cmd.exe /c " + ИмяCmd);
	
	ПодключитьОбработчикОжидания("ТаймерОжиданияСеансаОбмена",1);
КонецПроцедуры


//&НаСервере
//Функция НайтиФичуВМассиве(ИмяТекущейФичи,МассивДляСозданияEpf)
//	Объект1 = РеквизитФормыВЗначение("Объект");
//	Возврат Объект1.НайтиФичуВМассиве(ИмяТекущейФичи,МассивДляСозданияEpf);
//КонецФункции

&НаКлиенте
Функция НайтиФичуВМассиве(Стр) Экспорт
	Для Каждого Элем Из МассивДляСозданияEpf Цикл
		Если Элем.ИмяФичи = Стр Тогда
			Возврат Элем;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
КонецФункции

&НаКлиенте
Процедура ПоложитьТелоМодуляВСтруктураОписанияEpf(Стр,СтруктураОписанияEpf)
	Для Каждого Элем Из МассивДляСозданияEpf Цикл
		Если Элем.ИмяФичи = Стр Тогда
			Элем.ТелоМодуля = СтруктураОписанияEpf.ТелоМодуля;
			//Сообщить("Тест!!!");
			//Сообщить(Элем.ТелоМодуля);
			Возврат;
		КонецЕсли;
	КонецЦикла;
	
	ВызватьИсключение "Ошибка в ""ПоложитьТелоМодуляВСтруктураОписанияEpf""! Не найдена фича: " + Стр;
КонецПроцедуры


&НаСервере
Функция СоздатьПустуюСтруктуруEpf()
	Объект1 = РеквизитФормыВЗначение("Объект");
	Возврат Объект1.СоздатьПустуюСтруктуруEpf();
КонецФункции


&НаСервереБезКонтекста
Функция ЗагрузитьТелоМодуляВТаблицуЗначенийСервер(ДвоичныеДанные,ШагСтрокДляМодуля,ВернутьСтроку = Истина)
	//Если ТипЗнч(ФайлВХранилище) <> Тип("ДвоичныеДанные") Тогда
	//	ДвоичныеДанные = ФайлВХранилище.Получить();
	//Иначе
	//	ДвоичныеДанные = ФайлВХранилище;
	//КонецЕсли; 
	
	//ДвоичныеДанные = ФайлВХранилище.Получить();
	ПутьКФайлу = ПолучитьИмяВременногоФайла();
	ДвоичныеДанные.Записать(ПутьКФайлу);
	
	
	Тзн = Новый ТаблицаЗначений;
	Тзн.Колонки.Добавить("НомСтр");
	Тзн.Колонки.Добавить("Стр");
	
	НомСтр = 0;
	
	Текст = Новый ЧтениеТекста;
	Текст.Открыть(ПутьКФайлу,"UTF-8");
	
	Пока Истина Цикл
		Стр = Текст.ПрочитатьСтроку();
		Если Стр = Неопределено Тогда
			Прервать;
		КонецЕсли;	 
		
		НомСтр = НомСтр + ШагСтрокДляМодуля;
		
		СтрТзн        = Тзн.Добавить();
		СтрТзн.НомСтр = НомСтр;
		СтрТзн.Стр    = Стр;
	КонецЦикла;	
	
	Текст.Закрыть();
	
	Если Не ВернутьСтроку Тогда
		Возврат Тзн;
	КонецЕсли;	 
	
	Возврат ЗначениеВСтрокуВнутр(Тзн);
КонецФункции // ()


&НаКлиенте
Функция ЗагрузитьТелоМодуляВТаблицуЗначений(ПутьКФайлу)
	
	ДвоичныеДанные = Новый ДвоичныеДанные(ПутьКФайлу);
	//ФайлВХранилище = Новый ХранилищеЗначения(ДвоичныеДанные);
	
	Возврат ЗагрузитьТелоМодуляВТаблицуЗначенийСервер(ДвоичныеДанные,ШагСтрокДляМодуля);
КонецФункции


&НаСервере
Процедура ДобавитьНачальноеЗаполнениеВМодуль(ТелоМодуля,ШагСтрокДляМодуля,ГенерироватьУФ,ЭтоУФ)
	Объект1 = РеквизитФормыВЗначение("Объект");
	Объект1.ДобавитьНачальноеЗаполнениеВМодуль(ТелоМодуля,ШагСтрокДляМодуля,ГенерироватьУФ,ЭтоУФ);
КонецПроцедуры


&НаКлиенте
Процедура СоздатьИлиДополнитьСтруктурыДляEpfФайлов(ОтносительныйКаталогФичи)
	КаталогИнструментов = Объект.КаталогИнструментов;
	КаталогФич          = Объект.КаталогФич;
	ГенерироватьУФ      = Объект.ГенерироватьУФ;
	GenerateEpf         = Объект.GenerateEpf;
	
	Файл = Новый Файл(КаталогИнструментов + "\lib\TemplateEpf");
	Если Не Файл.Существует() Тогда
		СделатьСообщение("Не найден служебный каталог \lib\TemplateEpf !!!");
		Возврат;
	КонецЕсли;
	
	Если ИмяТекущейФичи = "" Тогда
		СделатьСообщение("Не определилась текущая фича из тегов feature файла.");
		Возврат;
	КонецЕсли;
	
	СтруктураОписанияEpf = НайтиФичуВМассиве(ИмяТекущейФичи);
	Если СтруктураОписанияEpf = Неопределено Тогда
		СтруктураОписанияEpf                    = СоздатьПустуюСтруктуруEpf();
		СтруктураОписанияEpf.ИмяФичи            = ИмяТекущейФичи;
		СтруктураОписанияEpf.ИмяФайлаEpf        = ОтносительныйКаталогФичи + "\step_definitions\" + ИмяТекущейФичи + ".epf";
		
		Если GenerateEpf Тогда
			ФайлEpf = Новый Файл(СтруктураОписанияEpf.ИмяФайлаEpf);
			Если ФайлEpf.Существует() Тогда //т.е. если мы не первый раз работаем с данной фичей
				СтруктураОписанияEpf.ИмяМодуляEpf       = РаспаковатьEPF(СтруктураОписанияEpf.ИмяФайлаEpf);
			КонецЕсли;	 
		КонецЕсли;	 
		СтруктураОписанияEpf.ВременноеИмяМодуля = КаталогИнструментов + "\lib\TemplateEpf\Temp\FormModule_" + ИмяТекущейФичи + ".txt";
		СтруктураОписанияEpf.КаталогИсходников  = КаталогИнструментов + "\lib\TemplateEpfUF";
		//если уже были исходники, то надо использовать их
		ПромИмяФайла = ОтносительныйКаталогФичи + "\step_definitions\src\" + ИмяТекущейФичи;
		ПромИсходникиФайл = Новый Файл(ПромИмяФайла);
		Если ПромИсходникиФайл.Существует() Тогда
			СтруктураОписанияEpf.КаталогИсходников = ПромИмяФайла;
		КонецЕсли;	 
		
		
		УдалитьФайлы(СтруктураОписанияEpf.ВременноеИмяМодуля);
		
		
		Файл = Новый Файл(СтруктураОписанияEpf.ВременноеИмяМодуля);
		Если Не Файл.Существует() Тогда
			//Сообщить(СтруктураОписанияEpf.ВременноеИмяМодуля);
			ЗТ = Новый ЗаписьТекста(СтруктураОписанияEpf.ВременноеИмяМодуля,"UTF-8",,Истина); 
			ЗТ.Закрыть();
		КонецЕсли;
		
		
		Файл = Новый Файл(СтруктураОписанияEpf.ИмяМодуляEpf); //значит надо загрузить модуль из исходников
		Если Файл.Существует() Тогда
			СтруктураОписанияEpf.ТелоМодуля = ЗагрузитьТелоМодуляВТаблицуЗначений(СтруктураОписанияEpf.ИмяМодуляEpf);
		Иначе
			СтруктураОписанияEpf.ТелоМодуля = ЗагрузитьТелоМодуляВТаблицуЗначений(СтруктураОписанияEpf.ВременноеИмяМодуля);
			//значит создаём файл первый разделим
			ДобавитьНачальноеЗаполнениеВМодуль(СтруктураОписанияEpf.ТелоМодуля,ШагСтрокДляМодуля,ГенерироватьУФ,Истина);
		КонецЕсли;
		
		
		
		
		МассивДляСозданияEpf.Добавить(СтруктураОписанияEpf);
		Отладка("Добавляю фичу " + СтруктураОписанияEpf.ИмяФичи + " в МассивДляСозданияEpf.");
	КонецЕсли;
	
	
	
КонецПроцедуры

&НаКлиенте
Процедура ТаймерДляГенерацииФич()
	КаталогИнструментов = Объект.КаталогИнструментов;
	
	Если СостояниеИдетГенерация Тогда
		Возврат;
	КонецЕсли;	 
	
	Если Не СостояниеИдетГенерация Тогда
		СостояниеИдетГенерация = Истина;
	КонецЕсли;	 
	
	Если ТекущаяПозицияМассивФайловФичДляГенерации > МассивФайловФичДляГенерации.Количество()-1 Тогда
		//значит перебрали все фичи
		ОтключитьОбработчикОжидания("ТаймерДляГенерацииФич");
		СделатьСообщение("Все фичи обработаны!");
		Если Объект.ЗакрытьФормуПослеВыполненияОбработки Тогда
			ЭтаФорма.Закрыть();
		КонецЕсли;	 
		Возврат;
	КонецЕсли;	
	
	
	Если ТекущаяПозицияМассивФайловФичДляГенерации = 0 Тогда
		СделатьСообщение("Всего найдено фич " + МассивФайловФичДляГенерации.Количество());
	КонецЕсли;	 
	
	ФайлФичи       = МассивФайловФичДляГенерации[ТекущаяПозицияМассивФайловФичДляГенерации];
	ИмяТекущейФичи = ФайлФичи.ИмяБезРасширения;
	СделатьСообщение("Работаю по фиче: " + ИмяТекущейФичи);
	
	МассивДляСозданияEpf = Новый Массив;
	//ОтносительныйКаталогФичи = СтрЗаменить(ФайлФичи.Путь,КаталогИнструментов,"");
	ОтносительныйКаталогФичи = ФайлФичи.Путь;
	Если Прав(ОтносительныйКаталогФичи,1) = "\" Тогда
		ОтносительныйКаталогФичи = Лев(ОтносительныйКаталогФичи,СтрДлина(ОтносительныйКаталогФичи)-1);
	КонецЕсли;	 
	
	Отладка("ОтносительныйКаталогФичи=" + ОтносительныйКаталогФичи);
	СоздатьИлиДополнитьСтруктурыДляEpfФайлов(ОтносительныйКаталогФичи);
	
	ТекущаяПозицияМассивФайловФичДляГенерации = ТекущаяПозицияМассивФайловФичДляГенерации + 1;
	
	БылиОшибкиЗапускаКукумбера = Ложь;
	ЗапуститьСерверДляКукумбера(БылиОшибкиЗапускаКукумбера,ФайлФичи.ПолноеИмя);
	Если БылиОшибкиЗапускаКукумбера Тогда
		ПрерватьВыполнениеСкрипта("Были ошибки запуска кукумбера!");
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура СделатьGenerateEpf()
	
	КаталогИнструментов = Объект.КаталогИнструментов;
	КаталогФич     = Объект.КаталогФич;
	
	ОтключитьОбработчикОжидания("ТаймерДляГенерацииФич");
	НачальныйКаталог = ПолучитьКаталогФич(КаталогИнструментов,КаталогФич);
	ОбработатьFeatureФайлыЧтобыПроставитьТегиСИменемФичиИЗаполнитьМассивНайденыхФич(НачальныйКаталог);
	МассивФайловФичДляГенерации = Новый Массив;
	СостояниеИдетГенерация = Ложь;
	ТекущаяПозицияМассивФайловФичДляГенерации = 0;
	
	
	Файл = Новый Файл(НачальныйКаталог);
	Если НРег(Файл.Расширение) = ".feature" Тогда
		БылиОшибкиЗапускаКукумбера = Ложь;
		МассивФайловФичДляГенерации.Добавить(Файл);
		ПодключитьОбработчикОжидания("ТаймерДляГенерацииФич",1);
		Возврат;
	КонецЕсли;
	
	МассивФайловФичДляГенерации = НайтиФайлы(НачальныйКаталог,"*.feature",Истина);
	ПодключитьОбработчикОжидания("ТаймерДляГенерацииФич",1);
	
	
	//ОбработатьFeatureФайлыЧтобыПроставитьТегиСИменемФичиИЗаполнитьМассивНайденыхФич(ПолучитьКаталогФич(Объект.КаталогИнструментов,Объект.КаталогФич));
	//
	//БылиОшибкиЗапускаКукумбера = Ложь;
	//ЗапуститьСерверДляКукумбера(БылиОшибкиЗапускаКукумбера);
	//Если БылиОшибкиЗапускаКукумбера Тогда
	//	ПрерватьВыполнениеСкрипта("Были ошибки запуска кукумбера!");
	//КонецЕсли;
	//
	//Если ОшибкаВнутриОбработкиВызоваBDD Тогда
	//	ПрерватьВыполнениеСкрипта("ОшибкаВнутриОбработкиВызоваBDD");
	//КонецЕсли;
	//
	//Если GenerateEpf Тогда
	//	БылиОшибки = Ложь;
	//	СоздатьФайлыОбработок(БылиОшибки);
	//КонецЕсли;
	
КонецПроцедуры


&НаСервере
Функция ПолучитьСледующуюСтрокуМодуля(СтрТзн,Тзн)
	Индекс = Тзн.Индекс(СтрТзн);
	Если Индекс = Тзн.Количество()-1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Тзн.Получить(Индекс+1);
КонецФункции


&НаСервере
Функция ПодключитьВнешнююОбработку(АдресХранилища)
    Возврат ВнешниеОбработки.Подключить(АдресХранилища,,Ложь); 
КонецФункции 

&НаСервере
Функция ПолучитьВнешниеОбработки()
	Возврат ВнешниеОбработки;
КонецФункции

&НаСервере
Процедура ДобавитьСнипет(Знач ID,Знач СтрокаРеальнойПроцедуры,Знач ИмяФайла,БылиОшибки,ТаблицаStepDefinition)
	
	СтрокаРеальнойПроцедуры = СокрЛП(СтрокаРеальнойПроцедуры);
	ID                      = СокрЛП(ID);
	
	//уберем слово "Экспорт"
	Если Прав(НРег(СтрокаРеальнойПроцедуры),7) = "экспорт" Тогда
		СтрокаРеальнойПроцедуры = Лев(СтрокаРеальнойПроцедуры,СтрДлина(СтрокаРеальнойПроцедуры)-7);
		СтрокаРеальнойПроцедуры = СокрЛП(СтрокаРеальнойПроцедуры);
	КонецЕсли;
	
	Если Лев(НРег(СтрокаРеальнойПроцедуры),9) = "процедура" Тогда
		СтрокаРеальнойПроцедуры = СокрЛП(Сред(СтрокаРеальнойПроцедуры,10));
	КонецЕсли;
	
	//Сообщить("ID="+ID);
	//Сообщить("СтрокаРеальнойПроцедуры="+СтрокаРеальнойПроцедуры);
	//Сообщить("ИмяФайла="+ИмяФайла);
	
	Поз = Найти(ID,"(");
	СтрПараметры = Сред(ID,Поз+1);
	СтрПараметры = Лев(СтрПараметры,СтрДлина(СтрПараметры)-1);
	
	//Сообщить("СтрПараметры="+СтрПараметры);
	
	МассивПром = РазложитьСтрокуВМассивПодстрок(СтрПараметры, ",");
	МассивПараметров = Новый Массив;
	Для Каждого Элем Из МассивПром Цикл
		СтруктураПарам = Новый Структура;
		Тип = "Строка";
		Если Найти(НРег(Элем),"число") > 0 Тогда
			Тип = "Число";
		КонецЕсли;
		Если Найти(НРег(Элем),"дата") > 0 Тогда
			Тип = "Дата";
		КонецЕсли;
		СтруктураПарам.Вставить("Тип",Тип);
		МассивПараметров.Добавить(СтруктураПарам);
		
		//Сообщить("Тип="+Тип + ", Элем=" + Элем);
	КонецЦикла;
	
	ПромСтр = ТаблицаStepDefinition.Найти(ID,"ID");
	Если ПромСтр <> Неопределено Тогда
		БылиОшибки = Истина;
		СделатьСообщениеСервер("Ошибка в файле " + ИмяФайла + ", снипет " + ID + " уже был в " + ПромСтр.ИмяФайла);
		Возврат;
	КонецЕсли;
	
	СтрТаблицаStepDefinition                         = ТаблицаStepDefinition.Добавить();
	СтрТаблицаStepDefinition.ID                      = ID;
	СтрТаблицаStepDefinition.СтрокаРеальнойПроцедуры = СтрокаРеальнойПроцедуры;
	СтрТаблицаStepDefinition.ИмяФайла                = ИмяФайла;
	СтрТаблицаStepDefinition.Параметры               = МассивПараметров;
КонецПроцедуры


&НаКлиенте
Процедура ОбработкаПолученияФайлаОбработкиТеста(Результат,АдресХранилища,ВыбранноеИмяФайла,ДополнительныеПараметры) Экспорт
	ИмяОбработки = ПодключитьВнешнююОбработку(АдресХранилища);
	Попытка
		Форма = ПолучитьФорму("ВнешняяОбработка." + ИмяОбработки + ".Форма.Форма");
	Исключение
		Возврат;
	КонецПопытки;
	Если Форма = Неопределено Тогда
		Возврат;
	КонецЕсли;	 
	
	
	СтрТаблицаКонтекстовОбработок           = ТаблицаКонтекстовОбработок.Добавить();
	СтрТаблицаКонтекстовОбработок.ИмяФайла  = ВыбранноеИмяФайла;
	СтрТаблицаКонтекстовОбработок.Обработка = ТаблицаКонтекстовОбработок.Количество()-1;
	
	МассивКонтекстовОбработок.Добавить(Форма);
	МассивИменФайлов.Добавить(ВыбранноеИмяФайла);
КонецПроцедуры




&НаКлиенте
Функция РаспаковатьEPF(ИмяФайла)
	КаталогИнструментов = Объект.КаталогИнструментов;
	Попытка
		
		Файл = Новый Файл(ИмяФайла);
		
		ИмяКаталогаДляИсходников = Файл.Путь + "Src";
		УдалитьФайлы(ИмяКаталогаДляИсходников);
		ФайлКаталогSrc = Новый Файл(ИмяКаталогаДляИсходников);
		Если Не ФайлКаталогSrc.Существует() Тогда
			СоздатьКаталог(ИмяКаталогаДляИсходников);
		КонецЕсли;	 
		
		СтрокаРазборкиEpf = "python " + КаталогИнструментов + "\vendor\precommit1c\pyv8unpack.py  """ +  ИмяФайла + """ """ + ИмяКаталогаДляИсходников + """";
		СделатьСообщение("Делаю распаковку " + Файл.ПолноеИмя);
		Отладка("Строка распаковки: " + СтрокаРазборкиEpf);
		КомандаСистемы(СтрокаРазборкиEpf,КаталогИнструментов);
		
		Если ЭтоУФ Тогда
			ПутьКФайлуМодуля = ИмяКаталогаДляИсходников + "\" + Файл.ИмяБезРасширения + "\Form\Форма\Форма.txt";
		Иначе	
			ПутьКФайлуМодуля = ИмяКаталогаДляИсходников + "\" + Файл.ИмяБезРасширения + "\ObjectModule.txt";
		КонецЕсли;	 
		
		Файл = Новый Файл(ПутьКФайлуМодуля);
		Если Не Файл.Существует() Тогда
			СделатьСообщение("Не найден файл после распаковки: " + ПутьКФайлуМодуля);
			Если ЭтоУФ Тогда
				СделатьСообщение("Возможно это обработка для обычных форм, а не для управляемых форм.");
			Иначе	
				СделатьСообщение("Возможно это обработка для управляемых форм, а не для обычных форм.");
			КонецЕсли;	 
			Возврат Неопределено;
		КонецЕсли;	 
		
		Возврат ПутьКФайлуМодуля;
	Исключение
		СделатьСообщение("Не смог распаковать " + ИмяФайла);
		СделатьСообщение(ОписаниеОшибки());
		Возврат Неопределено;
	КонецПопытки;
КонецФункции

&НаКлиенте
Процедура ПросканироватьИсходникиИНайтиВсеStepDefinition()
	КаталогИнструментов = Объект.КаталогИнструментов;
	КаталогФич     = Объект.КаталогФич;
	
	БылиОшибки = Ложь;
	НачальныйКаталог = ПолучитьКаталогФич(КаталогИнструментов,КаталогФич);
	КаталогПоиска    = НачальныйКаталог;
	
	Файл = Новый Файл(НачальныйКаталог);
	Если НРег(Файл.Расширение) = ".feature" Тогда
		КаталогПоиска = Файл.Путь;
	КонецЕсли;	 
	
	//Сообщить("КаталогПоиска="+КаталогПоиска);
	МассивФайлов = НайтиФайлы(КаталогПоиска,"*.epf",Истина);
	Для Каждого Файл Из МассивФайлов Цикл
		СтрТаблицаКонтекстовОбработок           = ТаблицаКонтекстовОбработок.Добавить();
		СтрТаблицаКонтекстовОбработок.ИмяФайла  = Файл.ПолноеИмя;
		
		
		
		Если ЭтоУФ Тогда
			
			ДополнительныеПараметры = Новый Структура;
			Если ЕстьПоддержкаНемодальныхФорм Тогда
				Оповещение = Вычислить("Новый ОписаниеОповещения(""ОбработкаПолученияФайлаОбработкиТеста"", ЭтаФорма, ДополнительныеПараметры)");
				Выполнить("НачатьПомещениеФайла(Оповещение,, Файл.ПолноеИмя, Ложь, УникальныйИдентификатор);");
			Иначе
				АдресХранилища = "";
				ПоместитьФайл(АдресХранилища, Файл.ПолноеИмя, , Ложь, УникальныйИдентификатор);
				//ПодключитьВнешнююОбработку(АдресХранилища);
				Результат = Неопределено;
				ОбработкаПолученияФайлаОбработкиТеста(Результат,АдресХранилища,Файл.ПолноеИмя,ДополнительныеПараметры);
			КонецЕсли;
			
			
			//АдресХранилища = "";
			//Параметр = Новый Структура;
			//Параметр.Вставить("ПолноеИмя",Файл.ПолноеИмя);
			//ОписаниеОповещения = Новый ОписаниеОповещения("ОбработкаПолученияФайлаОбработкиТеста", ЭтотОбъект,Параметр);
			//НачатьПомещениеФайла(ОписаниеОповещения,АдресХранилища, СтрТаблицаКонтекстовОбработок.ИмяФайла, Ложь);           
			//Возврат;
			////ОткрытьФорму("ВнешняяОбработка."+ ИмяОбработки +".Форма");
		Иначе	
			СтрТаблицаКонтекстовОбработок.Обработка = ПолучитьВнешниеОбработки().Создать(СтрТаблицаКонтекстовОбработок.ИмяФайла);
		КонецЕсли;	 
		
		//Рефлектор = Новый Рефлектор();
		//МассивАргументов = Новый Массив;
		//МассивАргументов.Добавить(1);
		//МассивАргументов.Добавить("фывфывфывфы");
		//Рефлектор.ВызватьМетод(СтрТаблицаКонтекстовОбработок.Обработка, "ПередНачаломСценария", МассивАргументов);
		
		//СтрТаблицаИзвестныхStepDefinition                 = ТаблицаИзвестныхStepDefinition.Добавить();
		//СтрТаблицаИзвестныхStepDefinition.ИмяФайла        = Файл.ПолноеИмя;
		//СтрТаблицаИзвестныхStepDefinition.ТаблицаПроцедур = СоздатьПустуюТаблицуПроцедур();
		
		Отладка("Путь="+Файл.ПолноеИмя);
		Стр = Файл.Путь;
		Стр = СтрЗаменить(Стр,КаталогИнструментов,КаталогИнструментов + "\Src");
		
		Если ЭтоУФ Тогда
			Стр = Стр + "" + Файл.ИмяБезРасширения + "\Form\Форма\Форма.txt";
		Иначе	
			Стр = Стр + "" + Файл.ИмяБезРасширения + "\ObjectModule.txt";
		КонецЕсли;	 
		
		//Сообщить("Стр="+Стр);
		
		ФайлМодуль = Новый Файл(Стр);
		Если Не ФайлМодуль.Существует() Тогда
			//значит мы не можем найти исходники epf и распакуем epf сами
			//ПрерватьВыполнениеСкрипта("Файл " + Стр + " не найден! Не могу найти StepDefinition.");
			Стр = РаспаковатьEPF(Файл.ПолноеИмя);
			Если Стр = Неопределено Тогда
				ПрерватьВыполнениеСкрипта("Для " + Файл.ПолноеИмя + " не были получены исходники!");
			КонецЕсли;	 
			//ПрерватьВыполнениеСкрипта("Файл " + Стр + " не найден! Не могу найти StepDefinition.");
		КонецЕсли;
		
		
		ДобавитьСнипетыИзФайла(Стр,Файл.ПолноеИмя);
		
		//ТелоМодуля = ЗагрузитьТелоМодуляВТаблицуЗначений(Стр);
		//
		//Для Каждого СтрТелоМодуля Из ТелоМодуля Цикл
		//	Если Лев(СтрТелоМодуля.Стр,3) = "//@" Тогда
		//		СледСтрока = ПолучитьСледующуюСтрокуМодуля(СтрТелоМодуля,ТелоМодуля);
		//		Если СледСтрока = Неопределено Тогда
		//			Продолжить;
		//		КонецЕсли;
		//		ДобавитьСнипет(Сред(СтрТелоМодуля.Стр,4),СледСтрока.Стр,Файл.ПолноеИмя,БылиОшибки);
		//		//Сообщить("" + СтрТелоМодуля.Стр);
		//	КонецЕсли;
		//КонецЦикла;
		
	КонецЦикла;
	
	Если БылиОшибки Тогда
		ПрерватьВыполнениеСкрипта("Были ошибки в ПросканироватьИсходникиИНайтиВсеStepDefinition.");
	КонецЕсли;
КонецПроцедуры

&НаСервере
Процедура ЗагрузитьСнипетыСервер(ДвоичныеДанные,ШагСтрокДляМодуля,ИмяФайла,ИмяEpf)
	ТелоМодуля = ЗагрузитьТелоМодуляВТаблицуЗначенийСервер(ДвоичныеДанные,ШагСтрокДляМодуля,Ложь);
	
	ТзнТаблицаИзвестныхStepDefinition = РеквизитФормыВЗначение("ТаблицаИзвестныхStepDefinition");
	
	Для Каждого СтрТелоМодуля Из ТелоМодуля Цикл
		Если Лев(СтрТелоМодуля.Стр,3) = "//@" Тогда
			СледСтрока = ПолучитьСледующуюСтрокуМодуля(СтрТелоМодуля,ТелоМодуля);
			Если СледСтрока = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			БылиОшибки = Ложь;
			ДобавитьСнипет(Сред(СтрТелоМодуля.Стр,4),СледСтрока.Стр,ИмяEpf,БылиОшибки,ТзнТаблицаИзвестныхStepDefinition);
			//Сообщить("" + СтрТелоМодуля.Стр);
		КонецЕсли;
	КонецЦикла;
	
	ЗначениеВРеквизитФормы(ТзнТаблицаИзвестныхStepDefinition,"ТаблицаИзвестныхStepDefinition");
	
КонецПроцедуры


&НаКлиенте
Процедура ДобавитьСнипетыИзФайла(ПутьКФайлу,ИмяEpf)
	ДвоичныеДанные = Новый ДвоичныеДанные(ПутьКФайлу);
	ЗагрузитьСнипетыСервер(ДвоичныеДанные,ШагСтрокДляМодуля,ПутьКФайлу,ИмяEpf);
КонецПроцедуры



&НаКлиенте
Процедура СделатьTestRun()
	КаталогИнструментов = Объект.КаталогИнструментов;
	КаталогФич          = Объект.КаталогФич;
	
	НачальныйКаталог = ПолучитьКаталогФич(КаталогИнструментов,КаталогФич);
	ОбработатьFeatureФайлыЧтобыПроставитьТегиСИменемФичиИЗаполнитьМассивНайденыхФич(НачальныйКаталог);
	
	ПросканироватьИсходникиИНайтиВсеStepDefinition();
	
	БылиОшибкиЗапускаКукумбера = Ложь;
	ЗапуститьСерверДляКукумбера(БылиОшибкиЗапускаКукумбера);
	Если БылиОшибкиЗапускаКукумбера Тогда
		ПрерватьВыполнениеСкрипта("Были ошибки запуска кукумбера!");
	КонецЕсли;
	
	Если ОшибкаВнутриОбработкиВызоваBDD Тогда
		ПрерватьВыполнениеСкрипта("ОшибкаВнутриОбработкиВызоваBDD");
	КонецЕсли;
	
	
КонецПроцедуры

&НаКлиенте
Процедура ВыполнитьОбработку() Экспорт
	GenerateEpf         = Объект.GenerateEpf;
	TestRun             = Объект.TestRun;
	КаталогИнструментов = Объект.КаталогИнструментов;
	КаталогФич          = Объект.КаталогФич;
	
	
	СделатьСообщение("Начало обработки.");
	
	Если Не СоздатьWinsock() Тогда
		Возврат;
	КонецЕсли;	 
	
	Если Прав(КаталогИнструментов,1) = "\" Тогда
		КаталогИнструментов = Лев(КаталогИнструментов,СтрДлина(КаталогИнструментов)-1);
	КонецЕсли;	 
	Если Прав(КаталогФич,1) = "\" Тогда
		КаталогФич = Лев(КаталогФич,СтрДлина(КаталогФич)-1);
	КонецЕсли;	 
	
	Инициализация();
	
	БылиОшибкиЗапускаКукумбера = Ложь;
	//Сообщить("WinSocket1.State = " + WinSocket1.State);
	Если WinSocket.State = 8 Тогда
		WinSocket.Close();
	КонецЕсли;	 
	
	
	Если TestRun и GenerateEpf Тогда
		ВызватьИсключение "Нельзя одновременно ставить TestRun и GenerateEpf!";
	КонецЕсли;	 
	
	Если GenerateEpf Тогда
		СделатьСообщение("Запускаю генерацию epf.");
		СделатьGenerateEpf();
	КонецЕсли;	 
	
	
	Если TestRun Тогда
		СделатьСообщение("Запускаю тесты.");
		СделатьTestRun();
	КонецЕсли;	 
КонецПроцедуры


&НаКлиенте
Процедура КнопкаВыполнить(Команда)
	ВыполнитьОбработку();
КонецПроцедуры

&НаСервере
Функция УзнатьЕстьПоддержкаНемодальныхФорм()
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Массив1 = РазложитьСтрокуВМассивПодстрок(СистемнаяИнформация.ВерсияПриложения,".");
	Массив2 = РазложитьСтрокуВМассивПодстрок("8.3.3.641",".");
	
	Версия1БольшеИлиРавно = Истина;
	Для Ккк = 0 По Массив1.Количество()-1 Цикл
		Элем1 = Массив1.Получить(Ккк);
		Элем2 = Массив2.Получить(Ккк);
		
		Если Число(Элем2) > Число(Элем1) Тогда
			Версия1БольшеИлиРавно = Ложь;
		КонецЕсли;	 
	КонецЦикла;
	
	Возврат Версия1БольшеИлиРавно;
КонецФункции


&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	ВосстановитьНастройки();
	
	
	ЕстьПоддержкаНемодальныхФорм = УзнатьЕстьПоддержкаНемодальныхФорм();

	Если Параметры.Свойство("GenerateEpf") Тогда
		Объект.GenerateEpf = Параметры.GenerateEpf;
	КонецЕсли;	 
	
	Если Параметры.Свойство("КаталогИнструментов") Тогда
		Объект.КаталогИнструментов = Параметры.КаталогИнструментов;
	КонецЕсли;	 
	
	Если Параметры.Свойство("КаталогФич") Тогда
		Объект.КаталогФич = Параметры.КаталогФич;
	КонецЕсли;	 
	
	Если Параметры.Свойство("ГенерироватьУФ") Тогда
		Объект.ГенерироватьУФ = Параметры.ГенерироватьУФ;
	КонецЕсли;	 
	
	Если Параметры.Свойство("DebugLog") Тогда
		Объект.DebugLog = Параметры.DebugLog;
	КонецЕсли;	 
	
	Если Параметры.Свойство("TestRun") Тогда
		Объект.TestRun = Параметры.TestRun;
	КонецЕсли;	 
	
	Если Параметры.Свойство("ВыполнитьОбработкуПриОткрытии") Тогда
		Объект.ВыполнитьОбработкуПриОткрытии = Параметры.ВыполнитьОбработкуПриОткрытии;
	КонецЕсли;	 
	
	Если Параметры.Свойство("ЗакрытьФормуПослеВыполненияОбработки") Тогда
		Объект.ЗакрытьФормуПослеВыполненияОбработки = Параметры.ЗакрытьФормуПослеВыполненияОбработки;
	КонецЕсли;	 
	
КонецПроцедуры

&НаСервере
Функция ПолучитьВерсиюОбработкиСервер()
	Объект1 = РеквизитФормыВЗначение("Объект");
	Возврат Объект1.ПолучитьВерсиюОбработки();
КонецФункции


&НаКлиенте
Процедура ПриОткрытии(Отказ)
	СтрВерсия = ПолучитьВерсиюОбработкиСервер();
	ЭтаФорма.Заголовок = СтрВерсия;
	Если Объект.ВыполнитьОбработкуПриОткрытии Тогда
		ВыполнитьОбработку();
	КонецЕсли;	 
КонецПроцедуры

&НаКлиенте
Процедура СоздатьШаблоныОбработок(Команда)
	Объект.GenerateEpf = Истина;
	Объект.TestRun     = Ложь;
	ВыполнитьОбработку();
КонецПроцедуры

&НаКлиенте
Процедура ЗапуститьТесты(Команда)
	Объект.GenerateEpf = Ложь;
	Объект.TestRun     = Истина;
	ВыполнитьОбработку();
КонецПроцедуры



СтримAdobe = Новый COMОбъект("Adodb.Stream");

RegExp            = Новый COMОбъект("VBScript.RegExp");
RegExp.IgnoreCase = Истина; //Игнорировать регистр
RegExp.Global     = Истина; //Поиск всех вхождений шаблона
RegExp.MultiLine  = Ложь; //Многострочный режим

ЭтоУФ = Истина;